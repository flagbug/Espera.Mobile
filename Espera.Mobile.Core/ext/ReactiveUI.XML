<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ReactiveUI</name>
    </assembly>
    <members>
        <member name="T:ReactiveUI.IReactiveBinding`3">
            <summary>
            This interface represents the result of a Bind/OneWayBind and gives
            information about the binding. When this object is disposed, it will
            destroy the binding it is describing (i.e. most of the time you won't
            actually care about this object, just that it is disposable)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:ReactiveUI.IReactiveBinding`3.ViewModel" -->
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewModelExpression">
            <summary>
            An expression representing the propertyon the viewmodel bound to the view.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.View">
            <summary>
            The instance of the view this binding is applied to.
            </summary>
            <value>
            The view.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewExpression">
            <summary>
            An expression representing the property on the view bound to the viewmodel.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Changed">
            <summary>
            An observable representing changed values for the binding.
            </summary>
            <value>
            The changed.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
            <value>
            The direction.
            </value>
        </member>
        <member name="M:ReactiveUI.ReactiveBinding`3.#ctor(`0,`1,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.IObservable{`2},ReactiveUI.BindingDirection,System.IDisposable)">
            <summary>
            Initializes a new instance of the <see cref="!:AppliedBindingInfo&lt;TViewModel&gt;"/> class.
            </summary>
            <param name="view">The view.</param>
            <param name="viewModel">The view model.</param>
            <param name="viewPath">The view path.</param>
            <param name="viewModelPath">The view model path.</param>
            <param name="direction">The direction.</param>
            <param name="bindingDisposable">The binding disposable.</param>
        </member>
        <member name="M:ReactiveUI.ReactiveBinding`3.Dispose">
            <summary>
            Releases unmanaged and - optionally - managed resources.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:ReactiveUI.ReactiveBinding`3.ViewModel" -->
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewModelExpression">
            <summary>
            An expression representing the propertyon the viewmodel bound to the view.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.View">
            <summary>
            The instance of the view this binding is applied to.
            </summary>
            <value>
            The view.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewExpression">
            <summary>
            An expression representing the property on the view bound to the viewmodel.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Changed">
            <summary>
            An observable representing changed values for the binding.
            </summary>
            <value>
            The changed.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
            <value>
            The direction.
            </value>
        </member>
        <member name="T:ReactiveUI.EqualityTypeConverter">
            <summary>
            The default converter, simply converts between types that are equal or
            can be converted (i.e. Button => UIControl)
            </summary>
        </member>
        <member name="T:ReactiveUI.IBindingTypeConverter">
            <summary>
            This interface is the extensible implementation of IValueConverters for 
            Bind and OneWayBind. Implement this to teach Bind and OneWayBind how to
            convert between types.
            </summary>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.GetAffinityForObjects(System.Type,System.Type)">
            <summary>
            Returns a positive integer when this class supports 
            TryConvert for this particular Type. If the method isn't supported at 
            all, return a non-positive integer. When multiple implementations 
            return a positive value, the host will use the one which returns 
            the highest value. When in doubt, return '2' or '0'.
            </summary>
            <param name="fromType">The source type to convert from</param>
            <param name="toType">The target type to convert to</param>
            <returns>A positive integer if TryConvert is supported, 
            zero or a negative value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <summary>
            Convert a given object to the specified type.
            </summary>
            <param name="from">The object to convert.</param>
            <param name="toType">The type to coerce the object to.</param>
            <param name="conversionHint">An implementation-defined value, 
            usually to specify things like locale awareness.</param>
            <returns>An object that is of the type 'to'</returns>
        </member>
        <member name="T:ReactiveUI.StringConverter">
            <summary>
            Calls ToString on types. In WPF, ComponentTypeConverter should win
            instead of this, since It's Betterâ„¢.
            </summary>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``3(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.String)">
            <summary>
            Bind a command from the ViewModel to the control on the View of the
            same name.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="propertyName">The ViewModel command to Bind.</param>
            <param name="toEvent">If specified, bind to the specific event 
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="propertyName">The ViewModel command to Bind.</param>
            <param name="withParameter">The ViewModel property to pass as the 
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event 
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="propertyName">The ViewModel command to Bind.</param>
            <param name="withParameter">The ViewModel property to pass as the 
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event 
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="toEvent">If specified, bind to the specific event 
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``1,``4}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="withParameter">The ViewModel property to pass as the 
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event 
            instead of the default.</param>
        </member>
        <member name="T:ReactiveUI.StockUserErrorIcon">
            <summary>
            Describes a stock error icon situation - it is up to the UI to decide
            how to interpret these icons.
            </summary>
        </member>
        <member name="T:ReactiveUI.IRecoveryCommand">
            <summary>
            A command that represents a recovery from an error. These commands
            will typically be displayed as buttons in the error dialog.
            </summary>
        </member>
        <member name="T:ReactiveUI.IHandleObservableErrors">
            <summary>
            This interface is implemented by RxUI objects which are given 
            IObservables as input - when the input IObservables OnError, instead of 
            disabling the RxUI object, we catch the IObservable and pipe it into
            this property.
            
            Normally this IObservable is implemented with a ScheduledSubject whose 
            default Observer is RxApp.DefaultExceptionHandler - this means, that if
            you aren't listening to ThrownExceptions and one appears, the exception
            will appear on the UI thread and crash the application.
            </summary>
        </member>
        <member name="P:ReactiveUI.IHandleObservableErrors.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI 
            internal state.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.CanExecuteObservable">
            <summary>
            Gets a value indicating whether this instance can execute observable.
            </summary>
            <value><c>true</c> if this instance can execute observable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:ReactiveUI.IReactiveCommand.IsExecuting">
            <summary>
            Gets a value indicating whether this instance is executing. This 
            Observable is guaranteed to always return a value immediately (i.e.
            it is backed by a BehaviorSubject), meaning it is safe to determine
            the current state of the command via IsExecuting.First()
            </summary>
            <value><c>true</c> if this instance is executing; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:ReactiveUI.IRecoveryCommand.CommandName">
            <summary>
            The command name, typically displayed as the button text.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRecoveryCommand.RecoveryResult">
            <summary>
            When the command is invoked and a result is determined, the
            command should set the recovery result to indicate the action the
            throwing code should take.
            </summary>
        </member>
        <member name="T:ReactiveUI.RecoveryOptionResult">
            <summary>
            RecoveryOptionResult describes to the code throwing the UserError what
            to do once the error is resolved.
            </summary>
        </member>
        <member name="F:ReactiveUI.RecoveryOptionResult.CancelOperation">
            <summary>
            The operation should be cancelled, but it is no longer an error.
            </summary>
        </member>
        <member name="F:ReactiveUI.RecoveryOptionResult.RetryOperation">
            <summary>
            The operation should be retried with the same parameters.
            </summary>
        </member>
        <member name="F:ReactiveUI.RecoveryOptionResult.FailOperation">
            <summary>
            Recovery failed or not possible, you should rethrow as an
            Exception.
            </summary>
        </member>
        <member name="T:ReactiveUI.UserError">
             <summary>
             User Errors are similar to Exceptions, except that they are intended
             to be displayed to the user. As such, your error messages should be
             phrased in a friendly way. When a UserError is thrown, code higher up
             in the stack has a chance to resolve the UserError via a user
             interaction. 
            
             Code can also add "Recovery Options" which resolve user errors: for
             example an "Out of Disk Space" error might have an "Open Explorer"
             recovery option.
             </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveObject">
            <summary>
            ReactiveObject is the base object for ViewModel classes, and it
            implements INotifyPropertyChanged. In addition, ReactiveObject provides
            Changing and Changed Observables to monitor object changes.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyPropertyChanged`1">
            <summary>
            IReactiveNotifyPropertyChanged represents an extended version of
            INotifyPropertyChanged that also exposes typed Observables.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveNotifyPropertyChanged`1.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged`1.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed. Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged`1.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.         
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.UserError.Throw(System.String,System.Exception)">
            <summary>
            Initiate a user interaction (i.e. "Throw the error to the user to
            deal with") - this method is the simplest way to prompt the user
            that an error has occurred.
            </summary>
            <param name="errorMessage">The message to show to the user. The
            upper level handlers registered with RegisterHandler are
            ultimately responsible for displaying this information.</param>
            <param name="innerException">The Exception that was thrown, if
            relevant - this will *not* ever be shown to the user.</param>
            <returns>An Observable representing the action the code should
            attempt to take, if any.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.Throw(ReactiveUI.UserError)">
            <summary>
            Initiate a user interaction (i.e. "Throw the error to the user to
            deal with"). 
            </summary>
            <param name="error">The UserError to show to the user. The
            upper level handlers registered with RegisterHandler are
            ultimately responsible for displaying this information. </param>
            <returns></returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler(System.Func{ReactiveUI.UserError,System.IObservable{ReactiveUI.RecoveryOptionResult}})">
             <summary>
             Register code to handle a UserError. Registered handlers are
             called in reverse order to their registration (i.e. the newest
             handler is called first), and they each have a chance to handle a
             UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler``1(System.Func{``0,System.IObservable{ReactiveUI.RecoveryOptionResult}})">
             <summary>
             Register code to handle a specific type of UserError. Registered
             handlers are called in reverse order to their registration (i.e.
             the newest handler is called first), and they each have a chance
             to handle a UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler(System.Func{ReactiveUI.UserError,System.Threading.Tasks.Task{ReactiveUI.RecoveryOptionResult}})">
             <summary>
             Register code to handle a UserError. Registered handlers are
             called in reverse order to their registration (i.e. the newest
             handler is called first), and they each have a chance to handle a
             UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.RegisterHandler``1(System.Func{``0,System.Threading.Tasks.Task{ReactiveUI.RecoveryOptionResult}})">
             <summary>
             Register code to handle a specific type of UserError. Registered
             handlers are called in reverse order to their registration (i.e.
             the newest handler is called first), and they each have a chance
             to handle a UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.AddRecoveryOption(ReactiveUI.IRecoveryCommand,System.Func{ReactiveUI.UserError,System.Boolean})">
            <summary>
            This method is a convenience wrapper around RegisterHandler that
            adds the specified RecoveryCommand to any UserErrors that match
            its filter.
            </summary>
            <param name="command">The RecoveryCommand to add.</param>
            <param name="filter">An optional filter to determine which
            UserErrors to add the command to.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.OverrideHandlersForTesting(System.Func{ReactiveUI.UserError,System.IObservable{ReactiveUI.RecoveryOptionResult}})">
            <summary>
            This method replaces *all* UserError handlers with the specified
            handler. Use it for testing code that may throw UserErrors.
            </summary>
            <param name="errorHandler">The replacement UserError handler.</param>
            <returns>An IDisposable which will unregister the test handler.</returns>
        </member>
        <member name="M:ReactiveUI.UserError.OverrideHandlersForTesting(System.Func{ReactiveUI.UserError,ReactiveUI.RecoveryOptionResult})">
            <summary>
            This method replaces *all* UserError handlers with the specified
            handler. Use it for testing code that may throw UserErrors.
            </summary>
            <param name="errorHandler">The replacement UserError handler.</param>
            <returns>An IDisposable which will unregister the test handler.</returns>
        </member>
        <member name="P:ReactiveUI.UserError.ContextInfo">
            <summary>
            A Dictionary that allows UserErrors to contain arbitrary
            application data.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.RecoveryOptions">
            <summary>
            The list of available Recovery Options that will be presented to
            the user to resolve the issue - these usually correspond to
            buttons in the dialog.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.ErrorMessage">
            <summary>
            The "Newspaper Headline" of the message being conveyed to the
            user. This should be one line, short, and informative.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.ErrorCauseOrResolution">
            <summary>
            Additional optional information to describe what is happening, or
            the resolution to an information-only error (i.e. a dialog to tell
            the user that something has happened)
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.UserErrorIcon">
            <summary>
            This object is either a custom icon (usually an ImageSource), or
            it can also be a StockUserErrorIcon. It can also be an
            application-defined type that the handlers know to interpret.
            </summary>
        </member>
        <member name="P:ReactiveUI.UserError.InnerException">
            <summary>
            Optionally, The actual Exception that warranted throwing the
            UserError.
            </summary>
        </member>
        <member name="T:ReactiveUI.UnhandledUserErrorException">
            <summary>
            This Exception will be thrown when a UserError is not handled by any
            of the registered handlers.
            </summary>
        </member>
        <member name="T:ReactiveUI.RecoveryCommand">
            <summary>
            RecoveryCommand is a straightforward implementation of a recovery
            command - this class represents a command presented to the user
            (usually in the form of a button) that will help resolve or mitigate a
            UserError.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveCommand`1">
            <summary>
            IReactiveCommand represents an ICommand which also notifies when it is
            executed (i.e. when Execute is called) via IObservable. Conceptually,
            this represents an Event, so as a result this IObservable should never
            OnComplete or OnError.
            
            In previous versions of ReactiveUI, this interface was split into two
            separate interfaces, one to handle async methods and one for "standard"
            commands, but these have now been merged - every ReactiveCommand is now
            a ReactiveAsyncCommand.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`1.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI 
            internal state.
            </summary>
            <value>The thrown exceptions.</value>
        </member>
        <member name="M:ReactiveUI.RecoveryCommand.#ctor(System.String,System.Func{System.Object,ReactiveUI.RecoveryOptionResult})">
            <summary>
            Constructs a RecoveryCommand.
            </summary>
            <param name="commandName">The user-visible name of this Command.</param>
            <param name="handler">A convenience handler - equivalent to
            Subscribing to the command and setting the RecoveryResult.</param>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.Ok">
            <summary>
            A default command whose caption is "Ok"
            </summary>
            <value>RetryOperation</value>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.Cancel">
            <summary>
            A default command whose caption is "Cancel"
            </summary>
            <value>FailOperation</value>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.Yes">
            <summary>
            A default command whose caption is "Yes"
            </summary>
            <value>RetryOperation</value>
        </member>
        <member name="P:ReactiveUI.RecoveryCommand.No">
            <summary>
            A default command whose caption is "No"
            </summary>
            <value>FailOperation</value>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.InitializeReactiveUI(Splat.IMutableDependencyResolver)">
            <summary>
            This method allows you to initialize resolvers with the default 
            ReactiveUI types. All resolvers used as the default 
            Locator.Current
            </summary>
            <param name="resolver">The resolver to initialize.</param>
        </member>
        <member name="T:ReactiveUI.INPCObservableForProperty">
            <summary>
            Generates Observables based on observing INotifyPropertyChanged objects
            </summary>
        </member>
        <member name="T:ReactiveUI.ICreatesObservableForProperty">
            <summary>
            ICreatesObservableForProperty represents an object that knows how to
            create notifications for a given type of object. Implement this if you
            are porting RxUI to a new UI toolkit, or generally want to enable WhenAny
            for another type of object that can be observed in a unique way.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports 
            GetNotificationForProperty for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'
            </summary>
            <param name="type">The type to query for.</param>
            <returns>A positive integer if GNFP is supported, zero or a negative
            value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetNotificationForProperty(System.Object,System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Subscribe to notifications on the specified property, given an 
            object and a property name.
            </summary>
            <param name="sender">The object to observe.</param>
            <param name="expression">The expression on the object to observe. 
            This will be either a MemberExpression or an IndexExpression
            dependending on the property.
            </param>
            <param name="beforeChanged">If true, signal just before the 
            property value actually changes. If false, signal after the 
            property changes.</param>
            <returns>An IObservable which is signalled whenever the specified
            property on the object changes. If this cannot be done for a 
            specified value of beforeChanged, return Observable.Never</returns>
        </member>
        <member name="T:ReactiveUI.IObservedChange`2">
            <summary>
            IObservedChange is a generic interface that is returned from WhenAny()
            Note that it is used for both Changing (i.e.'before change') 
            and Changed Observables.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Sender">
            <summary>
            The object that has raised the change.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Expression">
            <summary>
            The expression of the member that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Value">
            <summary>
            The value of the property that has changed. IMPORTANT NOTE: This
            property is often not set for performance reasons, unless you have
            explicitly requested an Observable for a property via a method such
            as ObservableForProperty. To retrieve the value for the property,
            use the GetValue() extension method.
            </summary>
        </member>
        <member name="T:ReactiveUI.ObservedChange`2">
            <summary>
            A data-only version of IObservedChange
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservedChange`2.#ctor(`0,System.Linq.Expressions.Expression,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ObservedChange`2"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="expression">Expression describing the member.</param>
            <param name="value">The value.</param>
        </member>
        <member name="T:ReactiveUI.IReactivePropertyChangedEventArgs`1">
            <summary>
            IReactivePropertyChangedEventArgs is a generic interface that 
            is used to wrap the NotifyPropertyChangedEventArgs and gives 
            information about changed properties. It includes also 
            the sender of the notification.
            Note that it is used for both Changing (i.e.'before change') 
            and Changed Observables.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactivePropertyChangedEventArgs`1.PropertyName">
            <summary>
            The name of the property that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactivePropertyChangedEventArgs`1.Sender">
            <summary>
            The object that has raised the change.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactivePropertyChangingEventArgs`1.#ctor(`0,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactivePropertyChangingEventArgs`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="M:ReactiveUI.ReactivePropertyChangedEventArgs`1.#ctor(`0,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactivePropertyChangedEventArgs`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyCollectionItemChanged`1">
            <summary>
            IReactiveNotifyCollectionItemChanged provides notifications for collection item updates, ie when an object in
            a collection changes.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionItemChanged`1.ItemChanging">
            <summary>
            Provides Item Changing notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionItemChanged`1.ItemChanged">
            <summary>
            Provides Item Changed notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionItemChanged`1.ChangeTrackingEnabled">
            <summary>
            Enables the ItemChanging and ItemChanged properties; when this is
            enabled, whenever a property on any object implementing
            IReactiveNotifyPropertyChanged changes, the change will be
            rebroadcast through ItemChanging/ItemChanged.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyCollectionChanged`1">
            <summary>
            IReactiveNotifyCollectionChanged of T provides notifications when the contents
            of collection are changed (items are added/removed/moved).
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ItemsAdded">
            <summary>
            Fires when items are added to the collection, once per item added.
            Functions that add multiple items such AddRange should fire this
            multiple times. The object provided is the item that was added.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.BeforeItemsAdded">
            <summary>
            Fires before an item is going to be added to the collection.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ItemsRemoved">
            <summary>
            Fires once an item has been removed from a collection, providing the
            item that was removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.BeforeItemsRemoved">
            <summary>
            Fires before an item will be removed from a collection, providing
            the item that will be removed. 
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.BeforeItemsMoved">
            <summary>
            Fires before an items moves from one position in the collection to
            another, providing the item(s) to be moved as well as source and destination
            indices.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ItemsMoved">
            <summary>
            Fires once one or more items moves from one position in the collection to
            another, providing the item(s) that was moved as well as source and destination
            indices.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.Changing">
            <summary>
            This Observable is equivalent to the NotifyCollectionChanged event,
            but fires before the collection is changed
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.Changed">
            <summary>
            This Observable is equivalent to the NotifyCollectionChanged event,
            and fires after the collection is changed
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.CountChanging">
            <summary>
            Fires when the collection count changes, regardless of reason
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.CountChanged">
            <summary>
            Fires when the collection count changes, regardless of reason
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ShouldReset">
            <summary>
            This Observable is fired when a ShouldReset fires on the collection. This
            means that you should forget your previous knowledge of the state
            of the collection and reread it.
            
            This does *not* mean Clear, and if you interpret it as such, you are
            Doing It Wrong.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveCollection`1">
             IReactiveCollection of T represents a collection that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
        </member>
        <member name="T:ReactiveUI.IReadOnlyReactiveCollection`1">
             <summary>
             IReadOnlyReactiveCollection of T represents a read-only collection that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
             </summary>
        </member>
        <member name="T:ReactiveUI.IReadOnlyReactiveList`1">
             <summary>
             IReadOnlyReactiveList of T represents a read-only list that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
             </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveDerivedList`1">
            <summary>
            IReactiveDerivedList represents a collection whose contents will "follow" another
            collection; this method is useful for creating ViewModel collections
            that are automatically updated when the respective Model collection is updated.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveList`1">
             <summary>
             IReactiveList of T represents a list that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
             </summary>
        </member>
        <member name="T:ReactiveUI.IRoutableViewModel">
            <summary>
            Implement this interface for ViewModels that can be navigated to.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.UrlPathSegment">
            <summary>
            A string token representing the current ViewModel, such as 'login' or 'user'
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.HostScreen">
            <summary>
            The IScreen that this ViewModel is currently being shown in. This
            is usually passed into the ViewModel in the Constructor and saved
            as a ReadOnly Property.
            </summary>
        </member>
        <member name="T:ReactiveUI.ViewContractAttribute">
            <summary>
            Allows an additional string to make view resolution more specific than just a type.
            </summary>
        </member>
        <member name="P:ReactiveUI.ViewContractAttribute.Contract">
            <summary>
            A unique string that will be used along with the type to resolve a View
            </summary>
        </member>
        <member name="T:ReactiveUI.IROObservableForProperty">
            <summary>
            Generates Observables based on observing Reactive objects
            </summary>
        </member>
        <member name="T:ReactiveUI.MessageBus">
             <summary>
             MessageBus represents an object that can act as a "Message Bus", a
             simple way for ViewModels and other objects to communicate with each
             other in a loosely coupled way.
            
             Specifying which messages go where is done via a combination of the Type
             of the message as well as an additional "Contract" parameter; this is a
             unique string used to distinguish between messages of the same Type, and
             is arbitrarily set by the client. 
             </summary>
        </member>
        <member name="T:ReactiveUI.IMessageBus">
             <summary>
             IMessageBus represents an object that can act as a "Message Bus", a
             simple way for ViewModels and other objects to communicate with each
             other in a loosely coupled way.
            
             Specifying which messages go where is done via a combination of the Type
             of the message as well as an additional "Contract" parameter; this is a
             unique string used to distinguish between messages of the same Type, and
             is arbitrarily set by the client. 
             </summary>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at
            runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified
            runtime and contract, this will overrwrite the existing
            registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract.
            CurrentThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns></returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            ListenIncludeLatest provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage and fire the 
            last provided Message immediately if applicable, or null.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The type of the message.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified runtime and contract, this will overrwrite the existing registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract. CurrentThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The Type of the message to listen to.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="P:ReactiveUI.MessageBus.Current">
            <summary>
            Gets or sets the Current MessageBus.
            </summary>
        </member>
        <member name="T:ReactiveUI.ISuspensionHost">
            <summary>
            ISuspensionHost represents a standardized version of the events that the
            host operating system publishes. Subscribe to these events in order to
            handle app suspend / resume.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsLaunchingNew">
            <summary>
            Signals when the application is launching new. This can happen when
            an app has recently crashed, as well as the first time the app has
            been launched. Apps should create their state from scratch.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsResuming">
            <summary>
            Signals when the application is resuming from suspended state (i.e. 
            it was previously running but its process was destroyed). 
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsUnpausing">
            <summary>
            Signals when the application is activated. Note that this may mean 
            that your process was not actively running before this signal.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.ShouldPersistState">
            <summary>
            Signals when the application should persist its state to disk.
            </summary>
            <value>Returns an IDisposable that should be disposed once the 
            application finishes persisting its state</value>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.ShouldInvalidateState">
            <summary>
            Signals that the saved application state should be deleted, this
            usually is called after an app has crashed
            </summary>
        </member>
        <member name="T:ReactiveUI.ISuspensionDriver">
            <summary>
            ISuspensionDriver represents a class that can load/save state to persistent
            storage. Most platforms have a basic implementation of this class, but you
            probably want to write your own.
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.LoadState">
            <summary>
            Loads the application state from persistent storage
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.SaveState(System.Object)">
            <summary>
            Saves the application state to disk.
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.InvalidateState">
            <summary>
            Invalidates the application state (i.e. deletes it from disk)
            </summary>
        </member>
        <member name="T:ReactiveUI.NullDefaultPropertyBindingProvider">
            <summary>
            Null default property binding provider.
            </summary>
        </member>
        <member name="T:ReactiveUI.IDefaultPropertyBindingProvider">
            <summary>
            Implement this to teach Bind and OneWayBind how to guess the most 
            "common" property on a given control, so if the caller doesn't specify it,
            it'll pick the right control
            </summary>
        </member>
        <member name="M:ReactiveUI.IDefaultPropertyBindingProvider.GetPropertyForControl(System.Object)">
            <summary>
            Given a certain control, figure out the default property to bind to
            </summary>
            <param name="control">The control to look at.</param>
            <returns>A tuple of PropertyName and Affinity for that property.
            Use the same rules about affinity as others, but return null if
            the property can't be determined.</returns>
        </member>
        <member name="T:ReactiveUI.ObservableAsPropertyHelper`1">
            <summary>
            ObservableAsPropertyHelper is a class to help ViewModels implement
            "output properties", that is, a property that is backed by an
            Observable. The property will be read-only, but will still fire change
            notifications. This class can be created directly, but is more often created via the
            ToProperty and ObservableToProperty extension methods.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.#ctor(System.IObservable{`0},System.Action{`0},`0,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs an ObservableAsPropertyHelper object.
            </summary>
            <param name="observable">The Observable to base the property on.</param>
            <param name="onChanged">The action to take when the property
            changes, typically this will call the ViewModel's
            RaisePropertyChanged method.</param>
            <param name="initialValue">The initial value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.Default(`0,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs a "default" ObservableAsPropertyHelper object. This is
            useful for when you will initialize the OAPH later, but don't want
            bindings to access a null OAPH at startup.
            </summary>
            <param name="initialValue">The initial (and only) value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.Value">
            <summary>
            The last provided value from the Observable. 
            </summary>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI 
            internal state.
            </summary>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.         
            </summary>
            <param name="source">The ReactiveObject that has the property</param>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty'</param>
            <param name="initialValue">The initial value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
            <returns>An initialized ObservableAsPropertyHelper; use this as the
            backing field for your property.</returns>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},ReactiveUI.ObservableAsPropertyHelper{``1}@,``1,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.         
            </summary>
            <param name="source">The ReactiveObject that has the property</param>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty'</param>
            <param name="initialValue">The initial value of the property.</param>
            <param name="scheduler">The scheduler that the notifications will be
            provided on - this should normally be a Dispatcher-based scheduler
            (and is by default)</param>
            <returns>An initialized ObservableAsPropertyHelper; use this as the
            backing field for your property.</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetPropertyName``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the current value of a property given a notification that
            it has changed.
            </summary>
            <returns>The current value of the property</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetValue``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the current value of a property given a notification that
            it has changed.
            </summary>
            <returns>The current value of the property</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.TryGetValue``2(ReactiveUI.IObservedChange{``0,``1},``1@)">
            <summary>
            Attempts to return the current value of a property given a 
            notification that it has changed. If any property in the
            property expression is null, false is returned.
            </summary>
            <param name="changeValue">The value of the property
            expression.</param>
            <returns>True if the entire expression was able to be followed,
            false otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.SetValueToProperty``3(ReactiveUI.IObservedChange{``0,``1},``2,System.Linq.Expressions.Expression{System.Func{``2,``1}})">
            <summary>
            Given a fully filled-out IObservedChange object, SetValueToProperty
            will apply it to the specified object (i.e. it will ensure that
            target.property == This.GetValue() and "replay" the observed change
            onto another object)
            </summary>
            <param name="target">The target object to apply the change to.</param>
            <param name="property">The target property to apply the change to.</param>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.Value``2(System.IObservable{ReactiveUI.IObservedChange{``0,``1}})">
            <summary>
            Given a stream of notification changes, this method will convert 
            the property changes to the current value of the property.
            </summary>
            <returns>An Observable representing the stream of current values of
            the given change notification stream.</returns>
        </member>
        <member name="T:ReactiveUI.IComparerBuilder`1">
            <summary>
            Convienience interface for providing a starting point for chaining comparers.
            </summary>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="T:ReactiveUI.OrderedComparer">
            <summary>
            Convienience class providing a starting point for chaining comparers for anonymous types.
            </summary>
            <remarks>
            If the type you're creating a comparer for is known this class is nothing more than an alias for the generic
            OrderedComparer. This class can be used to create comparers for anonymous types
            </remarks>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a type inferred comparer builder for the element type of the enumerable. Useful for creating
            comparers for anonymous types. Note that the builder is not a comparer in itself, you need to use the
            OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            </summary>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1">
            <summary>
            Creates a comparer builder for the specified type. Note that the builder is not a comparer in itself,
            you need to use the OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            If the type is known at compile time this method is nothing more than an alias for the generic
            OrdedComparer class.
            </summary>
        </member>
        <member name="T:ReactiveUI.OrderedComparer`1">
            <summary>
            Convienience class providing a starting point for chaining comparers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the 
            return type of the selector if no comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the 
            return type of the selector if no comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in ascending order based on the values returned by the provided selector. The selector values will be 
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in ascending order based on the values returned by the provided selector. The selector values will be 
            compared using the provided comparer or the default comparer for the return type of the selector if no 
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in descending order based on the values returned by the provided selector. The selector values will be 
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in descending order based on the values returned by the provided selector. The selector values will be 
            compared using the provided comparer or the default comparer for the return type of the selector if no 
            comparer is specified.
            </summary>
            <param name="selector">A function supplying the values for the comparator.</param>
        </member>
        <member name="T:ReactiveUI.POCOObservableForProperty">
            <summary>
            This class is the final fallback for WhenAny, and will simply immediately
            return the value of the type at the time it was created. It will also 
            warn the user that this is probably not what they want to do
            </summary>
        </member>
        <member name="T:ReactiveUI.BindingMixins">
            <summary>
            This class provides extension methods for the ReactiveUI view binding mechanism.
            </summary>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view =&gt; view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``3(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Object)">
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property, and 
            provide a custom view update signaller to signal when the view property has been updated.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view =&gt; view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.IObservable{``3},System.Object)">
            <summary>
            Binds the specified view model property to an automagically guessed control/property on the view, and 
            provide a custom view update signaller to signal when the view property has been updated.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the given property on the view model to a given property on the view in a one-way (view model to view) fashion.
            </summary>
            <typeparam name="TViewModel">The type of the view model.</typeparam>
            <typeparam name="TView">The type of the view.</typeparam>
            <typeparam name="TVMProp">The type of view model property.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">
            The instance of the view object which is bound. Usually, it is the <code>this</code>
            instance.
            </param>
            <param name="viewModel">
            The view model that is bound. 
            It is usually set to the <see cref="P:ReactiveUI.IViewFor.ViewModel"/> property of the <paramref name="view"/>.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view =&gt; view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="fallbackValue">
            A function providing a fallback value. 
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``3(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2},System.Object)">
            <summary>
            Binds the specified view model property property to the given view in a one-way (view model to view) fashion,
            and tries to automagically guess the control/property to be bound on the
            view by looking at the name of the property bound on the view model.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="fallbackValue">
            A function providing a fallback value. 
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Binds the specified view model property to the given view, in a one-way (view model to view) fashion,
            with the value of the view model property mapped through a <paramref name="selector"/> function.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Binds the specified view model property to the given view, automagically guessing
            the control/property to be bound, in a one-way (view model to view) fashion,
            with the value of the view model property mapped through a <paramref name="selector"/> function.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to "Subscribe(x =&gt;
            target.property = x)", but allows you to use child properties
            without the null checks.
            </summary>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">An expression representing the target
            property to set. This can be a child property (i.e. x.Foo.Bar.Baz).</param>
            <param name="fallbackValue">
            A function that provides a fallback value.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBinderImplementation">
            <summary>
            This interface represents an object that is capable
            of providing binding implementations.
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the 
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp"/> to <typeparamref name="TVProp"/>.
            </exception>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only, and where the value of the view model
            property is mapped through the <paramref name="selector"/> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to "Subscribe(x =&gt;
            target.property = x)", but allows you to use child properties
            without the null checks.
            </summary>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">An expression representing the target
            property to set. This can be a child property (i.e. x.Foo.Bar.Baz).</param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the 
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <see cref="!:vmProperty"/>, and its most natural property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <see cref="!:vmProperty"/>, and its most natural property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp"/> to <typeparamref name="TVProp"/>.
            </exception>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only, and where the value of the view model
            property is mapped through the <paramref name="selector"/> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <see cref="!:vmProperty"/>, and its most natural property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <param name="fallbackValue">
            A function that provides a fallback value. Note that this property is IGNORED in this implementation.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Func{``0},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to "Subscribe(x =>
            target.property = x)", but allows you to use child properties
            without the null checks.
            </summary>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">An expression representing the target
            property to set. This can be a child property (i.e. x.Foo.Bar.Baz).</param>
            <returns>An object that when disposed, disconnects the binding.</returns>
            <param name="This">This.</param>
            <param name="fallbackValue">Fallback value.</param>
            <param name="conversionHint">Conversion hint.</param>
            <param name="vmToViewConverterOverride">Vm to view converter override.</param>
            <typeparam name="TValue">The 1st type parameter.</typeparam>
            <typeparam name="TTarget">The 2nd type parameter.</typeparam>
            <typeparam name="TTValue">The 3rd type parameter.</typeparam>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`1">
            <summary>
            This class represents a change-notifying Collection which is derived from
            a source collection, via CreateDerivedCollection or via another method. 
            It is read-only, and any attempts to change items in the collection will
            fail.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`2">
            <summary>
            This class represents a change-notifying Collection which is derived from
            a source collection, via CreateDerivedCollection or via another method. 
            It is read-only, and any attempts to change items in the collection will
            fail.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.canItemStayAtPosition(`1,System.Int32)">
            <summary>
            Gets a value indicating whether or not the item fits (sort-wise) at the provided index. The determination
            is made by checking whether or not it's considered larger than or equal to the preceeding item and if
            it's less than or equal to the succeeding item.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.getIndexFromSourceIndex(System.Int32)">
            <summary>
            Gets the index of the dervived item based on it's originating element index in the source collection.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.indexOfAll(System.Collections.Generic.IEnumerable{`0},`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns one or more positions in the source collection where the given item is found based on the
            provided equality comparer.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.moveSourceIndexInMap(System.Int32,System.Int32)">
            <summary>
            Increases (or decreases depending on move direction) all source indices between the source and destination
            move indices.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.shiftIndicesAtOrOverThreshold(System.Int32,System.Int32)">
            <summary>
            Increases (or decreases) all source indices equal to or higher than the threshold. Represents an
            insert or remove of one or more items in the source list thus causing all subsequent items to shift
            up or down.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.shiftSourceIndicesInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Increases (or decreases) all source indices within the range (lower inclusive, upper exclusive). 
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.newPositionForExistingItem(System.Int32,System.Int32,`1)">
            <summary>
            Calculates a new destination for an updated item that's already in the list.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.newPositionForExistingItem``1(System.Collections.Generic.IList{``0},``0,System.Int32,System.Func{``0,``0,System.Int32})">
            <summary>
            Calculates a new destination for an updated item that's already in the list.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`2.ReferenceEqualityComparer`1">
            <summary>
            Internal equality comparer used for looking up the source object of a property change notification in
            the source list.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveCollectionMixins.CreateCollection``1(System.IObservable{``0},System.Nullable{System.TimeSpan},System.Action{System.Exception})">
            <summary>
            Creates a collection based on an an Observable by adding items
            provided until the Observable completes, optionally ensuring a
            delay. Note that if the Observable never completes and withDelay is
            set, this method will leak a Timer. This method also guarantees that
            items are always added via the UI thread.
            </summary>
            <param name="fromObservable">The Observable whose items will be put
            into the new collection.</param>
            <param name="onError">The handler for errors from the Observable. If
            not specified, an error will go to DefaultExceptionHandler.</param>
            <param name="withDelay">If set, items will be populated in the
            collection no faster than the delay provided.</param>
            <returns>A new collection which will be populated with the
            Observable.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCollectionMixins.CreateCollection``2(System.IObservable{``0},System.Func{``0,``1},System.Nullable{System.TimeSpan})">
            <summary>
            Creates a collection based on an an Observable by adding items
            provided until the Observable completes, optionally ensuring a
            delay. Note that if the Observable never completes and withDelay is
            set, this method will leak a Timer. This method also guarantees that
            items are always added via the UI thread.
            </summary>
            <param name="fromObservable">The Observable whose items will be put
            into the new collection.</param>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="withDelay">If set, items will be populated in the
            collection no faster than the delay provided.</param>
            <returns>A new collection which will be populated with the
            Observable.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.IObservable{``2},System.Reactive.Concurrency.IScheduler)">
             <summary>
             Creates a collection whose contents will "follow" another
             collection; this method is useful for creating ViewModel collections
             that are automatically updated when the respective Model collection
             is updated.
            
             Note that even though this method attaches itself to any 
             IEnumerable, it will only detect changes from objects implementing
             INotifyCollectionChanged (like ReactiveList). If your source
             collection doesn't implement this, signalReset is the way to signal
             the derived collection to reorder/refilter itself.
             </summary>
             <param name="selector">A Select function that will be run on each
             item.</param>
             <param name="filter">A filter to determine whether to exclude items 
             in the derived collection.</param>
             <param name="orderer">A comparator method to determine the ordering of
             the resulting collection.</param>
             <param name="signalReset">When this Observable is signalled, 
             the derived collection will be manually 
             reordered/refiltered.</param>
             <returns>A new collection whose items are equivalent to
             Collection.Select().Where().OrderBy() and will mirror changes 
             in the initial collection.</returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a collection whose contents will "follow" another
            collection; this method is useful for creating ViewModel collections
            that are automatically updated when the respective Model collection
            is updated.
            
            Be aware that this overload will result in a collection that *only* 
            updates if the source implements INotifyCollectionChanged. If your
            list changes but isn't a ReactiveList/ObservableCollection,
            you probably want to use the other overload.
            </summary>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="filter">A filter to determine whether to exclude items 
            in the derived collection.</param>
            <param name="orderer">A comparator method to determine the ordering of
            the resulting collection.</param>
            <returns>A new collection whose items are equivalent to
            Collection.Select().Where().OrderBy() and will mirror changes 
            in the initial collection.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateCombined(System.IObservable{System.Boolean},ReactiveUI.IReactiveCommand[])">
            <summary>
            This creates a ReactiveCommand that calls several child 
            ReactiveCommands when invoked. Its CanExecute will match the
            combined result of the child CanExecutes (i.e. if any child
            commands cannot execute, neither can the parent)
            </summary>
            <param name="canExecute">An Observable that determines whether the 
            parent command can execute</param>
            <param name="commands">The commands to combine.</param>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.ToCommand(System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            ToCommand is a convenience method for returning a new
            ReactiveCommand based on an existing Observable chain.
            </summary>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand whose CanExecute Observable is the
            current object.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,System.Windows.Input.ICommand}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.OnExecuteCompleted``1(ReactiveUI.ReactiveCommand{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>
            A convenience method for subscribing and creating ReactiveCommands 
            in the same call. Equivalent to Subscribing to the command, except
            there's no way to release your Subscription but that's probably fine.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject. This method (unlike other Observables that return
            IObservedChange) guarantees that the Value property of
            the IObservedChange is set.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty.SomeOtherProperty'</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,``2},System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject, running the IObservedChange through a Selector
            function.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty'</param>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBindingHook">
            <summary>
            Implement this as a way to intercept bindings at the time that they are
            created and execute an additional action (or to cancel the binding)
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBindingHook.ExecuteHook(System.Object,System.Object,System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},ReactiveUI.BindingDirection)">
            <summary>
            Called when any binding is set up.
            </summary>
            <returns>If false, the binding is cancelled</returns>
            <param name="source">The source ViewModel</param>
            <param name="target">The target View (not the actual control)</param>
            <param name="getCurrentViewModelProperties">Get current view model properties.</param>
            <param name="getCurrentViewProperties">Get current view properties.</param>
            <param name="direction">The Binding direction.</param>
        </member>
        <member name="T:ReactiveUI.IViewFor`1">
            <summary>
            Implement this interface on your Views to support Routing and Binding.
            </summary>
        </member>
        <member name="P:ReactiveUI.IViewFor`1.ViewModel">
            <summary>
            The ViewModel corresponding to this specific View. This should be
            a DependencyProperty if you're using XAML.
            </summary>
        </member>
        <member name="T:ReactiveUI.IScreen">
            <summary>
            IScreen represents any object that is hosting its own routing -
            usually this object is your AppViewModel or MainWindow object.
            </summary>
        </member>
        <member name="P:ReactiveUI.IScreen.Router">
            <summary>
            The Router associated with this Screen.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.GetAffinityForObject(System.Type,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports 
            BindCommandToObject for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'
            </summary>
            <param name="type">The type to query for.</param>
            <param name="hasEventTarget">If true, the host intends to use a custom
            event target.</param>
            <returns>A positive integer if BCTO is supported, zero or a negative
            value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object})">
            <summary>
            Bind an ICommand to a UI object, in the "default" way. The meaning 
            of this is dependent on the implementation. Implement this if you
            have a new type of UI control that doesn't have 
            Command/CommandParameter like WPF or has a non-standard event name
            for "Invoke".
            </summary>
            <param name="command">The command to bind</param>
            <param name="target">The target object, usually a UI control of 
            some kind</param>
            <param name="commandParameter">An IObservable source whose latest 
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be 
            Observable.Empty</param>
            <returns>An IDisposable which will disconnect the binding when 
            disposed.</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject``1(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object},System.String)">
            <summary>
            Bind an ICommand to a UI object to a specific event. This event may
            be a standard .NET event, or it could be an event derived in another
            manner (i.e. in MonoTouch).
            </summary>
            <param name="command">The command to bind</param>
            <param name="target">The target object, usually a UI control of 
            some kind</param>
            <param name="commandParameter">An IObservable source whose latest 
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be 
            Observable.Empty</param>
            <param name="eventName">The event to bind to.</param>
            <returns></returns>
            <returns>An IDisposable which will disconnect the binding when 
            disposed.</returns>
        </member>
        <member name="T:ReactiveUI.IViewLocator">
            <summary>
            Implement this to override how RoutedViewHost and ViewModelViewHost
            map ViewModels to Views.
            </summary>
        </member>
        <member name="M:ReactiveUI.IViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Determines the view for an associated ViewModel
            </summary>
            <returns>The view, with the ViewModel property assigned to 
            viewModel.</returns>
            <param name="viewModel">View model.</param>
            <param name="contract">Contract.</param>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatedTo(ReactiveUI.IRoutableViewModel,System.Func{System.IDisposable})">
            <summary>
            This method allows you to set up connections that only operate
            while the ViewModel has focus, and cleans up when the ViewModel
            loses focus.
            </summary>
            <param name="onNavigatedTo">Called when the ViewModel is navigated
            to - return an IDisposable that cleans up all of the things that are
            configured in the method.</param>
            <returns>An IDisposable that lets you disconnect the entire process
            earlier than normal.</returns>
        </member>
        <member name="T:ReactiveUI.RoutingState">
            <summary>
            RoutingState manages the ViewModel Stack and allows ViewModels to
            navigate to other ViewModels.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigationStack">
            <summary>
            Represents the current navigation stack, the last element in the
            collection being the currently visible ViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateBack">
            <summary>
            Navigates back to the previous element in the stack.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.Navigate">
            <summary>
            Navigates to the a new element in the stack - the Execute parameter
            must be a ViewModel that implements IRoutableViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateAndReset">
            <summary>
            Navigates to a new element and resets the navigation stack (i.e. the
            new ViewModel will now be the only element in the stack) - the
            Execute parameter must be a ViewModel that implements
            IRoutableViewModel.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.FindViewModelInStack``1(ReactiveUI.RoutingState)">
            <summary>
            Locate the first ViewModel in the stack that matches a certain Type.
            </summary>
            <returns>The matching ViewModel or null if none exists.</returns>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.GetCurrentViewModel(ReactiveUI.RoutingState)">
            <summary>
            Returns the currently visible ViewModel
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.NavigateCommandFor``1(ReactiveUI.RoutingState)">
            <summary>
            Creates a ReactiveCommand which will, when invoked, navigate to the 
            type specified by the type parameter via looking it up in the
            Dependency Resolver.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.MainThreadScheduler">
            <summary>
            MainThreadScheduler is the scheduler used to schedule work items that
            should be run "on the UI thread". In normal mode, this will be
            DispatcherScheduler, and in Unit Test mode this will be Immediate,
            to simplify writing common unit tests.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.TaskpoolScheduler">
            <summary>
            TaskpoolScheduler is the scheduler used to schedule work items to
            run in a background thread. In both modes, this will run on the TPL
            Task Pool (or the normal Threadpool on Silverlight).
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.DefaultExceptionHandler">
            <summary>
            This Observer is signalled whenever an object that has a 
            ThrownExceptions property doesn't Subscribe to that Observable. Use
            Observer.Create to set up what will happen - the default is to crash
            the application with an error message.
            </summary>
        </member>
        <member name="M:ReactiveUI.DefaultViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Returns the View associated with a ViewModel, deriving the name of
            the Type via ViewModelToViewFunc, then discovering it via
            ServiceLocator.
            </summary>
            <param name="viewModel">The ViewModel for which to find the
            associated View.</param>
            <returns>The View for the ViewModel.</returns>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of a
            property on an object has changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{ReactiveUI.IObservedChange{``0,``2},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``2,``3,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{``2,``3,``4,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{``2,``3,``4,``5,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{``2,``3,``4,``5,``6,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{``2,``3,``4,``5,``6,``7,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{``2,``3,``4,``5,``6,``7,``8,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},ReactiveUI.IObservedChange{``0,``13},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="T:ReactiveUI.WaitForDispatcherScheduler">
            <summary>
            This scheduler attempts to deal with some of the brain-dead defaults
            on certain Microsoft platforms that make it difficult to access the
            Dispatcher during startup. This class wraps a scheduler and if it
            isn't available yet, it simply runs the scheduled item immediately.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaiseAndSetIfChanged``2(``0,``1@,``1,System.String)">
            <summary>
            RaiseAndSetIfChanged fully implements a Setter for a read-write
            property on a ReactiveObject, using CallerMemberName to raise the notification
            and the ref to the backing field to set the property.
            </summary>
            <typeparam name="TObj">The type of the This.</typeparam>
            <typeparam name="TRet">The type of the return value.</typeparam>
            <param name="This">The <see cref="T:ReactiveUI.ReactiveObject"/> raising the notification.</param>
            <param name="backingField">A Reference to the backing field for this
            property.</param>
            <param name="newValue">The new value.</param>
            <param name="propertyName">The name of the property, usually 
            automatically provided through the CallerMemberName attribute.</param>
            <returns>The newly set value, normally discarded.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaisePropertyChanged(ReactiveUI.IReactiveObject,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <param name="This">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaisePropertyChanging(ReactiveUI.IReactiveObject,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <param name="This">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.suppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.WeakEventManager`3">
            <summary>
            WeakEventManager base class. Inspired by the WPF WeakEventManager class and the code in 
            http://social.msdn.microsoft.com/Forums/silverlight/en-US/34d85c3f-52ea-4adc-bb32-8297f5549042/command-binding-memory-leak?forum=silverlightbugs
            </summary>
            <typeparam name="TEventSource">The type of the event source.</typeparam>
            <typeparam name="TEventHandler">The type of the event handler.</typeparam>
            <typeparam name="TEventArgs">The type of the event arguments.</typeparam>
        </member>
        <member name="F:ReactiveUI.WeakEventManager`3.targetToEventHandler">
            <summary>
            Mapping between the target of the delegate (for example a Button) and the handler (EventHandler).
            Windows Phone needs this, otherwise the event handler gets garbage collected.
            </summary>
        </member>
        <member name="F:ReactiveUI.WeakEventManager`3.sourceToWeakHandlers">
            <summary>
            Mapping from the source of the event to the list of handlers. This is a CWT to ensure it does not leak the source of the event.
            </summary>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.WeakEventManager`3"/> class.
            Protected to disallow instances of this class and force a subclass.
            </summary>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.AddHandler(`0,`1)">
            <summary>
            Adds a weak reference to the handler and associates it with the source.
            </summary>
            <param name="source">The source.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.RemoveHandler(`0,`1)">
            <summary>
            Removes the association between the source and the handler.
            </summary>
            <param name="source">The source.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.DeliverEvent(`0,`2)">
            <summary>
            Delivers the event to the handlers registered for the source. 
            </summary>
            <param name="sender">The sender.</param>
            <param name="args">The <see cref="!:TEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.StartListening(System.Object)">
            <summary>
            Override this method to attach to an event.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.StopListening(System.Object)">
            <summary>
            Override this method to detach from an event.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="T:ReactiveUI.CreatesCommandBindingViaEvent">
            <summary>
            This binder is the default binder for connecting to arbitrary events
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.ReactiveCommand">
            <summary>
            ReactiveCommand is the default Command implementation in ReactiveUI, which
            conforms to the spec described in IReactiveCommand. 
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateCombined(System.IObservable{System.Boolean},ReactiveUI.Legacy.ReactiveCommand[])">
            <summary>
            This creates a ReactiveCommand that calls several child 
            ReactiveCommands when invoked. Its CanExecute will match the
            combined result of the child CanExecutes (i.e. if any child
            commands cannot execute, neither can the parent)
            </summary>
            <param name="canExecute">An Observable that determines whether the 
            parent command can execute</param>
            <param name="commands">The commands to combine.</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.RegisterAsync``1(System.Func{System.Object,System.IObservable{``0}})">
            <summary>
            Registers an asynchronous method to be called whenever the command
            is Executed. This method returns an IObservable representing the
            asynchronous operation, and is allowed to OnError / should OnComplete.
            </summary>
            <returns>A filtered version of the Observable which is marshaled 
            to the UI thread. This Observable should only report successes and
            instead send OnError messages to the ThrownExceptions property.</returns>
            <param name="asyncBlock">The asynchronous method to call.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="P:ReactiveUI.Legacy.ReactiveCommand.IsExecuting">
            <summary>
            Gets a value indicating whether this instance is executing. This 
            Observable is guaranteed to always return a value immediately (i.e.
            it is backed by a BehaviorSubject), meaning it is safe to determine
            the current state of the command via IsExecuting.First()
            </summary>
            <value>true</value>
            <c>false</c>
        </member>
        <member name="P:ReactiveUI.Legacy.ReactiveCommand.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI 
            internal state.
            </summary>
            <value>The thrown exceptions.</value>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.ToCommand(System.IObservable{System.Boolean},System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            ToCommand is a convenience method for returning a new
            ReactiveCommand based on an existing Observable chain.
            </summary>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand whose CanExecute Observable is the
            current object.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,System.Windows.Input.ICommand}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.RegisterAsyncFunction``1(ReactiveUI.Legacy.ReactiveCommand,System.Func{System.Object,``0},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterAsyncFunction registers an asynchronous method that returns a result
            to be called whenever the Command's Execute method is called.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
            <param name="scheduler"></param>
            <returns>An Observable that will fire on the UI thread once per
            invoecation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.RegisterAsyncAction(ReactiveUI.Legacy.ReactiveCommand,System.Action{System.Object},System.Reactive.Concurrency.IScheduler)">
            <summary>
            RegisterAsyncAction registers an asynchronous method that runs
            whenever the Command's Execute method is called and doesn't return a
            result.
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.RegisterAsyncTask``1(ReactiveUI.Legacy.ReactiveCommand,System.Func{System.Object,System.Threading.Tasks.Task{``0}})">
            <summary>
            RegisterAsyncTask registers an TPL/Async method that runs when a 
            Command gets executed and returns the result
            </summary>
            <returns>An Observable that will fire on the UI thread once per
            invoecation of Execute, once the async method completes. Subscribe to
            this to retrieve the result of the calculationFunc.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.RegisterAsyncTask(ReactiveUI.Legacy.ReactiveCommand,System.Func{System.Object,System.Threading.Tasks.Task})">
            <summary>
            RegisterAsyncTask registers an TPL/Async method that runs when a 
            Command gets executed and returns no result. 
            </summary>
            <param name="calculationFunc">The function to be run in the
            background.</param>
            <returns>An Observable that signals when the Task completes, on
            the UI thread.</returns>
        </member>
    </members>
</doc>
